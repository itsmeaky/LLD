step 1: OOP & SOLID Principles (Core Foundation)
Object-Oriented Programming Concepts
1.	Encapsulation â†’ wrapping data + methods together (class)
ğŸ‘‰ Interview Q: How does C++ achieve encapsulation?
âœ… Answer: By using classes, access specifiers (private, protected, public), getters/setters.
2.	Abstraction â†’ hiding implementation details, showing only whatâ€™s necessary
ğŸ‘‰ Q: Difference between abstraction and encapsulation?
âœ… Encapsulation = data hiding inside a class
âœ… Abstraction = hiding implementation via abstract classes / interfaces
3.	Inheritance â†’ one class acquiring properties of another
ğŸ‘‰ Q: Types in C++? (Single, Multiple, Multilevel, Hybrid, Hierarchical)
ğŸ‘‰ Q: When to avoid inheritance? â€“ when â€œis-aâ€ relation doesnâ€™t hold (prefer composition).
4.	Polymorphism â†’ many forms
o	Compile-time (function overloading, operator overloading)
o	Run-time (virtual functions, overriding)
ğŸ‘‰ Q: When to use virtual destructor?
âœ… If base pointer deletes a derived object, destructor must be virtual to avoid memory leaks.
SOLID Principles
1.	S â€“ Single Responsibility: A class should only have one reason to change.
Eg: ParkingLot shouldnâ€™t both manage payments and assign slots.
2.	O â€“ Open/Closed: Classes should be open for extension, closed for modification.
Eg: Add new VehicleType without modifying ParkingSlot allocation code â†’ use polymorphism.
3.	L â€“ Liskov Substitution: Derived classes must be substitutable for base classes.
Eg: If Car inherits Vehicle, anywhere Vehicle is expected, Car should work correctly.
4.	I â€“ Interface Segregation: Clients shouldnâ€™t be forced to depend on unused interfaces.
Eg: Donâ€™t put printReceipt() inside Vehicle interface; only Payment should have it.
5.	D â€“ Dependency Inversion: Depend on abstractions, not concrete classes.
Eg: PaymentService should depend on IPaymentMethod (interface), not directly on CreditCard.
Example With Virtual Destructor
class Base {
public:
    virtual ~Base() {   // Virtual destructor
        cout << "Base Destructor" << endl;
    }
};

class Derived : public Base {
public:
    ~Derived() {
        cout << "Derived Destructor" << endl;
    }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;   // Both destructors called âœ…
    return 0;
}
ğŸ”¹ What is the Diamond Problem?
It happens in multiple inheritance when a class inherits from two classes that share a common base.
This creates ambiguity because the derived class may inherit multiple copies of the same base class.


Singleton : 
1. What is the Singleton Pattern?
âœ… Ensures only one instance of a class exists and provides a global access point.
ğŸ‘‰ Example use: Logger, DB Connection Pool, Thread Pool.

#include <iostream>
using namespace std;

class Singleton {
private:
    static Singleton* instance;
    Singleton() { cout << "Singleton created\n"; }
public:
    static Singleton* getInstance() {
        if (!instance) instance = new Singleton();
        return instance;
    }
    void show() { cout << "Using Singleton\n"; }
};
Singleton* Singleton::instance = nullptr;

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();
    cout << (s1 == s2 ? "Same instance\n" : "Different instance\n");
}

2. What is the Factory Method Pattern?
âœ… Provides an interface for creating objects, but lets subclasses decide which object to create.
ğŸ‘‰ Example use: VehicleFactory creates Car/Bike/Truck.
#include <iostream>
using namespace std;

class Vehicle {
public:
    virtual void drive() = 0;
};
class Car : public Vehicle {
public: void drive() { cout << "Driving Car\n"; }
};
class Bike : public Vehicle {
public: void drive() { cout << "Riding Bike\n"; }
};

class VehicleFactory {
public:
    static Vehicle* create(string type) {
        if (type == "car") return new Car();
        if (type == "bike") return new Bike();
        return nullptr;
    }
};

int main() {
    Vehicle* v1 = VehicleFactory::create("car");
    v1->drive();
    Vehicle* v2 = VehicleFactory::create("bike");
    v2->drive();
}
________________________________________
3. What is the Builder Pattern?
âœ… Used to construct complex objects step by step.
ğŸ‘‰ Example use: Building a Pizza with toppings, crust, size.
#include <iostream>
using namespace std;

class Pizza {
public:
    string dough, sauce, topping;
    void show() { cout << "Pizza with " << dough << ", " << sauce << ", " << topping << "\n"; }
};

class PizzaBuilder {
protected:
    Pizza* pizza;
public:
    PizzaBuilder() { pizza = new Pizza(); }
    virtual void buildDough() = 0;
    virtual void buildSauce() = 0;
    virtual void buildTopping() = 0;
    Pizza* getPizza() { return pizza; }
};

class MargheritaBuilder : public PizzaBuilder {
public:
    void buildDough() { pizza->dough = "Thin"; }
    void buildSauce() { pizza->sauce = "Tomato"; }
    void buildTopping() { pizza->topping = "Cheese"; }
};

class Director {
public:
    Pizza* create(PizzaBuilder& builder) {
        builder.buildDough();
        builder.buildSauce();
        builder.buildTopping();
        return builder.getPizza();
    }
};

int main() {
    MargheritaBuilder builder;
    Director director;
    Pizza* p = director.create(builder);
    p->show();
}
________________________________________
ğŸ”¹ Structural Design Patterns
4. What is the Adapter Pattern?
âœ… Converts the interface of a class into another interface clients expect.
ğŸ‘‰ Example use: Integrating a new payment gateway with existing system.
#include <iostream>
using namespace std;

class OldPrinter {
public: void oldPrint() { cout << "Old Printer\n"; }
};
class ModernPrinter {
public: virtual void print() = 0;
};
class Adapter : public ModernPrinter {
    OldPrinter* oldPrinter;
public:
    Adapter(OldPrinter* p) : oldPrinter(p) {}
    void print() override { oldPrinter->oldPrint(); }
};

int main() {
    OldPrinter old;
    ModernPrinter* printer = new Adapter(&old);
    printer->print();
}
________________________________________
5. What is the Decorator Pattern?
âœ… Dynamically adds behavior to objects without modifying original code.
ğŸ‘‰ Example use: Adding notifications (Email â†’ SMS â†’ Push).
#include <iostream>
using namespace std;

class Notifier {
public: virtual void send() = 0;
};
class EmailNotifier : public Notifier {
public: void send() { cout << "Email sent\n"; }
};
class SMSDecorator : public Notifier {
    Notifier* wrappee;
public:
    SMSDecorator(Notifier* n) : wrappee(n) {}
    void send() { wrappee->send(); cout << "SMS sent\n"; }
};

int main() {
    Notifier* n = new SMSDecorator(new EmailNotifier());
    n->send();
}
________________________________________
6. What is the Composite Pattern?
âœ… Treats individual objects and compositions uniformly (tree structures).
ğŸ‘‰ Example use: File System (File + Folder).
#include <iostream>
#include <vector>
using namespace std;

class FileSystem {
public: virtual void show() = 0;
};
class File : public FileSystem {
    string name;
public:
    File(string n) : name(n) {}
    void show() { cout << "File: " << name << "\n"; }
};
class Folder : public FileSystem {
    string name;
    vector<FileSystem*> children;
public:
    Folder(string n) : name(n) {}
    void add(FileSystem* f) { children.push_back(f); }
    void show() {
        cout << "Folder: " << name << "\n";
        for (auto c : children) c->show();
    }
};

int main() {
    Folder root("root");
    root.add(new File("a.txt"));
    Folder* sub = new Folder("docs");
    sub->add(new File("b.pdf"));
    root.add(sub);
    root.show();
}
________________________________________
7. What is the Proxy Pattern?
âœ… Provides a placeholder for another object to control access.
ğŸ‘‰ Example use: Virtual Proxy for expensive objects (like large images).
#include <iostream>
using namespace std;

class Image {
public: virtual void display() = 0;
};
class RealImage : public Image {
    string filename;
public:
    RealImage(string f) : filename(f) { cout << "Loading " << f << "\n"; }
    void display() { cout << "Displaying " << filename << "\n"; }
};
class ProxyImage : public Image {
    string filename;
    RealImage* realImg = nullptr;
public:
    ProxyImage(string f) : filename(f) {}
    void display() {
        if (!realImg) realImg = new RealImage(filename);
        realImg->display();
    }
};

int main() {
    Image* img = new ProxyImage("photo.png");
    img->display(); // loads + displays
    img->display(); // reuses cached image
}
________________________________________
ğŸ”¹ Behavioral Design Patterns
8. What is the Strategy Pattern?
âœ… Defines a family of algorithms, encapsulates each one, and makes them interchangeable.
ğŸ‘‰ Example use: Payment strategy (CreditCard, UPI, Wallet).
#include <iostream>
using namespace std;

class Payment {
public: virtual void pay(int amount) = 0;
};
class CreditCard : public Payment {
public: void pay(int amount) { cout << "Paid " << amount << " with Credit Card\n"; }
};
class UPI : public Payment {
public: void pay(int amount) { cout << "Paid " << amount << " with UPI\n"; }
};
class Order {
    Payment* method;
public:
    Order(Payment* p) : method(p) {}
    void checkout(int amt) { method->pay(amt); }
};

int main() {
    Order o1(new CreditCard());
    o1.checkout(100);
    Order o2(new UPI());
    o2.checkout(200);
}
________________________________________
9. What is the Observer Pattern?
âœ… One-to-many dependency: when subject changes, observers get notified.
ğŸ‘‰ Example use: Notification system (user gets SMS, Email).
#include <iostream>
#include <vector>
using namespace std;

class Observer {
public: virtual void update(string msg) = 0;
};
class User : public Observer {
    string name;
public:
    User(string n) : name(n) {}
    void update(string msg) { cout << name << " received: " << msg << "\n"; }
};
class NotificationService {
    vector<Observer*> users;
public:
    void subscribe(Observer* u) { users.push_back(u); }
    void notify(string msg) { for (auto u : users) u->update(msg); }
};

int main() {
    User u1("Alice"), u2("Bob");
    NotificationService service;
    service.subscribe(&u1);
    service.subscribe(&u2);
    service.notify("New Offer!");
}
________________________________________
10. What is the Command Pattern?
âœ… Encapsulates a request as an object, allowing undo/redo operations.
ğŸ‘‰ Example use: Text editor (undo/redo).
#include <iostream>
#include <vector>
using namespace std;

class Command {
public: virtual void execute() = 0;
};
class Light {
public: void on() { cout << "Light ON\n"; }
        void off() { cout << "Light OFF\n"; }
};
class LightOn : public Command {
    Light* light;
public: LightOn(Light* l) : light(l) {}
    void execute() { light->on(); }
};
class Remote {
    vector<Command*> history;
public:
    void press(Command* c) { c->execute(); history.push_back(c); }
};

int main() {
    Light light;
    Remote remote;
    Command* on = new LightOn(&light);
    remote.press(on);
}
________________________________________
11. What is the State Pattern?
âœ… Allows an object to change its behavior when its state changes.
ğŸ‘‰ Example use: Vending machine (Idle, HasMoney, Dispensing).
#include <iostream>
using namespace std;

class State {
public: virtual void handle() = 0;
};
class Idle : public State {
public: void handle() { cout << "Machine is Idle\n"; }
};
class Working : public State {
public: void handle() { cout << "Machine is Working\n"; }
};
class Machine {
    State* state;
public:
    Machine(State* s) : state(s) {}
    void setState(State* s) { state = s; }
    void request() { state->handle(); }
};

int main() {
    Machine m(new Idle());
    m.request();
    m.setState(new Working());
    m.request();
}
________________________________________
12. What is the Chain of Responsibility Pattern?
âœ… Passes request along a chain until one handler processes it.
ğŸ‘‰ Example use: Logging levels (Info â†’ Debug â†’ Error).
#include <iostream>
using namespace std;

class Handler {
protected: Handler* next = nullptr;
public:
    void setNext(Handler* n) { next = n; }
    virtual void handle(int level) {
        if (next) next->handle(level);
    }
};
class InfoHandler : public Handler {
public: void handle(int level) {
    if (level == 1) cout << "Info log\n";
    else Handler::handle(level);
} };
class ErrorHandler : public Handler {
public: void handle(int level) {
    if (level == 2) cout << "Error log\n";
    else Handler::handle(level);
} };

int main() {
    InfoHandler info; ErrorHandler error;
    info.setNext(&error);
    info.handle(1);
    info.handle(2);
}
________________________________________
ğŸ”¹ Concurrency Patterns
13. Producer-Consumer Problem
âœ… One or more producers generate data, consumers use it.
ğŸ‘‰ Solved using mutex + condition_variable in C++.
________________________________________
14. Thread Pool Pattern
âœ… Reuses a fixed set of worker threads to execute tasks.
ğŸ‘‰ Used in web servers for handling requests.
ğŸ”¹ 1. Parking Lot System
Q: How would you design a Parking Lot System?
âœ… Answer outline:
â€¢	Entities: ParkingLot, ParkingFloor, ParkingSpot, Vehicle (Car/Bike/Truck), Ticket, Payment.
â€¢	Key requirements: assign nearest free spot, generate ticket, calculate fees, support multiple vehicle types.
â€¢	Patterns:
o	Singleton â†’ ParkingLot (only one lot manager).
o	Factory â†’ Create Vehicle objects.
o	Strategy â†’ Different pricing algorithms (weekday/weekend).
________________________________________
ğŸ”¹ 2. Elevator System
Q: Design an Elevator system.
âœ… Answer outline:
â€¢	Entities: ElevatorController, Elevator, Floor, Request.
â€¢	Key requirements: handle multiple elevators, schedule efficiently (nearest-car algorithm).
â€¢	Patterns:
o	Observer â†’ Notify floors when elevator arrives.
o	State â†’ Elevator states (Idle, Moving, DoorOpen).
o	Strategy â†’ Different scheduling policies.
________________________________________
ğŸ”¹ 3. Food Delivery (Zomato/Swiggy)
Q: How to design a food delivery app?
âœ… Answer outline:
â€¢	Entities: Customer, Restaurant, Menu, Order, DeliveryPartner, Payment.
â€¢	Key requirements: browse restaurants, place order, assign delivery partner.
â€¢	Patterns:
o	Observer â†’ Notify customer about order status.
o	Strategy â†’ Payment options (UPI, Card, Wallet).
o	Factory â†’ Restaurant can create MenuItems.
________________________________________
ğŸ”¹ 4. BookMyShow / Ticket Booking
Q: Design a ticket booking system.
âœ… Answer outline:
â€¢	Entities: Theater, Screen, Show, Seat, Booking, Payment.
â€¢	Key requirements: check seat availability, hold seat until payment, prevent double-booking.
â€¢	Patterns:
o	Singleton â†’ Booking manager.
o	Strategy â†’ Payment methods.
o	Observer â†’ Notify user when booking confirmed.
________________________________________
ğŸ”¹ 5. Ride Sharing (Uber/Ola)
Q: How would you design Uber?
âœ… Answer outline:
â€¢	Entities: Rider, Driver, Trip, Location, Payment.
â€¢	Key requirements: match rider with nearby driver, calculate fare, tracking.
â€¢	Patterns:
o	Strategy â†’ Fare calculation.
o	Observer â†’ Notify rider/driver on trip updates.
o	Singleton â†’ TripManager.
________________________________________
ğŸ”¹ 6. ATM / Vending Machine
Q: Design an ATM.
âœ… Answer outline:
â€¢	Entities: ATM, Card, Account, Transaction, CashDispenser.
â€¢	Key requirements: withdraw, deposit, check balance, pin validation.
â€¢	Patterns:
o	State â†’ ATM states (Idle, CardInserted, TransactionInProgress).
o	Strategy â†’ Different withdrawal limits per account type.
________________________________________
ğŸ”¹ 7. Notification Service
Q: How to design a Notification Service?
âœ… Answer outline:
â€¢	Entities: Notification, Channel (SMS/Email/Push), User.
â€¢	Key requirements: send notification via multiple channels, scalable.
â€¢	Patterns:
o	Observer â†’ Users subscribe to notifications.
o	Strategy â†’ Choose channel dynamically.
o	Decorator â†’ Add new notification types without modifying core code.
________________________________________
ğŸ”¹ 8. Rate Limiter
Q: How would you design a Rate Limiter?
âœ… Answer outline:
â€¢	Entities: RateLimiter, UserRequest.
â€¢	Algorithms: Token Bucket, Leaky Bucket, Fixed Window, Sliding Window.
â€¢	Key requirements: prevent API abuse, different rules for different users.
â€¢	Patterns:
o	Singleton â†’ Global limiter instance.
o	Strategy â†’ Different rate limiting algorithms.
________________________________________
ğŸ”¹ 9. Cache (LRU, LFU)
Q: Design an LRU Cache.
âœ… Answer outline:
â€¢	Entities: Cache, Node, DoublyLinkedList.
â€¢	Key requirements: O(1) get() and put().
â€¢	Approach: HashMap + Doubly Linked List.
â€¢	Patterns:
o	Singleton â†’ Global cache.
o	Strategy â†’ Replacement policies (LRU, LFU).
________________________________________
ğŸ”¹ 10. Messaging Queue (Kafka-like)
Q: Design a Messaging Queue.
âœ… Answer outline:
â€¢	Entities: Producer, Consumer, MessageQueue.
â€¢	Key requirements: publish-subscribe model, ordered delivery, persistence.
â€¢	Patterns:
o	Observer â†’ Consumers subscribe to topics.
o	Singleton â†’ Queue manager.
o	Producer-Consumer â†’ Thread synchronization.

